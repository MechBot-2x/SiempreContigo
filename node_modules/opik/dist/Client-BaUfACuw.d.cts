import * as stream from 'stream';

interface OpikConfig {
    apiKey: string;
    apiUrl?: string;
    projectName: string;
    workspaceName: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type FindFeedbackDefinitionsRequestType = "numerical" | "categorical";
declare const FindFeedbackDefinitionsRequestType: {
    readonly Numerical: "numerical";
    readonly Categorical: "categorical";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface FindFeedbackDefinitionsRequest {
    page?: number;
    size?: number;
    name?: string;
    type?: FindFeedbackDefinitionsRequestType;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ProviderApiKeyWriteProvider = "openai" | "anthropic" | "gemini" | "openrouter";
declare const ProviderApiKeyWriteProvider: {
    readonly Openai: "openai";
    readonly Anthropic: "anthropic";
    readonly Gemini: "gemini";
    readonly Openrouter: "openrouter";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         provider: "openai",
 *         apiKey: "api_key"
 *     }
 */
interface ProviderApiKeyWrite {
    provider: ProviderApiKeyWriteProvider;
    apiKey: string;
    name?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         apiKey: "api_key"
 *     }
 */
interface ProviderApiKeyUpdate {
    apiKey: string;
    name?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ProjectMetricRequestPublicMetricType = "FEEDBACK_SCORES" | "TRACE_COUNT" | "TOKEN_USAGE" | "DURATION" | "COST";
declare const ProjectMetricRequestPublicMetricType: {
    readonly FeedbackScores: "FEEDBACK_SCORES";
    readonly TraceCount: "TRACE_COUNT";
    readonly TokenUsage: "TOKEN_USAGE";
    readonly Duration: "DURATION";
    readonly Cost: "COST";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ProjectMetricRequestPublicInterval = "HOURLY" | "DAILY" | "WEEKLY";
declare const ProjectMetricRequestPublicInterval: {
    readonly Hourly: "HOURLY";
    readonly Daily: "DAILY";
    readonly Weekly: "WEEKLY";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindProjectsRequest {
    page?: number;
    size?: number;
    name?: string;
    sorting?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface ProjectWrite {
    name: string;
    description?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface ProjectUpdate {
    name?: string;
    description?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNamesByProjectIdsRequest {
    projectIds?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface ProjectMetricRequestPublic {
    metricType?: ProjectMetricRequestPublicMetricType;
    interval?: ProjectMetricRequestPublicInterval;
    intervalStart?: Date;
    intervalEnd?: Date;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetProjectStatsRequest {
    page?: number;
    size?: number;
    name?: string;
    sorting?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface ProjectRetrieveDetailed {
    name: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type PromptWriteType = "mustache" | "jinja2";
declare const PromptWriteType: {
    readonly Mustache: "mustache";
    readonly Jinja2: "jinja2";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetPromptsRequest {
    page?: number;
    size?: number;
    name?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface PromptWrite {
    id?: string;
    name: string;
    description?: string;
    template?: string;
    metadata?: JsonNodeWrite;
    changeDescription?: string;
    type?: PromptWriteType;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         name: "name",
 *         version: {
 *             template: "template"
 *         }
 *     }
 */
interface CreatePromptVersionDetail {
    name: string;
    version: PromptVersionDetail;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface PromptUpdatable {
    name: string;
    description?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetPromptVersionsRequest {
    page?: number;
    size?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface PromptVersionRetrieveDetail {
    name: string;
    commit?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type GetSpansByProjectRequestType = "general" | "tool" | "llm";
declare const GetSpansByProjectRequestType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type FindFeedbackScoreNames1RequestType = "general" | "tool" | "llm";
declare const FindFeedbackScoreNames1RequestType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type GetSpanStatsRequestType = "general" | "tool" | "llm";
declare const GetSpanStatsRequestType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type SpanSearchStreamRequestPublicType = "general" | "tool" | "llm";
declare const SpanSearchStreamRequestPublicType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface GetSpansByProjectRequest {
    page?: number;
    size?: number;
    projectName?: string;
    projectId?: string;
    traceId?: string;
    type?: GetSpansByProjectRequestType;
    filters?: string;
    truncate?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         spans: [{
 *                 traceId: "trace_id",
 *                 name: "name",
 *                 type: "general",
 *                 startTime: "2024-01-15T09:30:00Z"
 *             }]
 *     }
 */
interface SpanBatchWrite {
    spans: SpanWrite[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         traceId: "trace_id"
 *     }
 */
interface SpanUpdate$1 {
    /** If null and project_id not specified, Default Project is assumed */
    projectName?: string;
    /** If null and project_name not specified, Default Project is assumed */
    projectId?: string;
    traceId: string;
    parentSpanId?: string;
    endTime?: Date;
    input?: JsonNode;
    output?: JsonNode;
    metadata?: JsonNode;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    totalEstimatedCost?: number;
    errorInfo?: ErrorInfo;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNames1Request {
    projectId?: string;
    type?: FindFeedbackScoreNames1RequestType;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface GetSpanStatsRequest {
    projectId?: string;
    projectName?: string;
    traceId?: string;
    type?: GetSpanStatsRequestType;
    filters?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface SpanSearchStreamRequestPublic {
    traceId?: string;
    projectName?: string;
    projectId?: string;
    type?: SpanSearchStreamRequestPublicType;
    filters?: SpanFilterPublic[];
    limit?: number;
    lastRetrievedId?: string;
    /** Truncate image included in either input, output or metadata */
    truncate?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindEvaluatorsRequest {
    projectId?: string;
    name?: string;
    page?: number;
    size?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         projectId: "project_id",
 *         body: {
 *             ids: ["ids"]
 *         }
 *     }
 */
interface DeleteAutomationRuleEvaluatorBatchRequest {
    projectId: string;
    body: BatchDelete;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetEvaluatorByIdRequest {
    projectId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetEvaluatorLogsByIdRequest {
    size?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindEvaluatorsDeprecatedRequest {
    name?: string;
    page?: number;
    size?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetEvaluatorLogsByIdDeprecatedRequest {
    size?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface ChatCompletionRequest {
    model?: string;
    messages?: Message[];
    temperature?: number;
    topP?: number;
    n?: number;
    stream?: boolean;
    streamOptions?: StreamOptions;
    stop?: string[];
    maxTokens?: number;
    maxCompletionTokens?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
    logitBias?: Record<string, number>;
    user?: string;
    responseFormat?: ResponseFormat;
    seed?: number;
    tools?: Tool[];
    toolChoice?: Record<string, unknown>;
    parallelToolCalls?: boolean;
    functions?: Function[];
    functionCall?: FunctionCall;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindDatasetsRequest {
    page?: number;
    size?: number;
    withExperimentsOnly?: boolean;
    promptId?: string;
    name?: string;
    sorting?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface DatasetWrite {
    id?: string;
    name: string;
    description?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         items: [{
 *                 source: "manual",
 *                 data: {
 *                     "key": "value"
 *                 }
 *             }]
 *     }
 */
interface DatasetItemBatchWrite {
    /** If null, dataset_id must be provided */
    datasetName?: string;
    /** If null, dataset_name must be provided */
    datasetId?: string;
    items: DatasetItemWrite[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface DatasetUpdate {
    name: string;
    description?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         datasetName: "dataset_name"
 *     }
 */
interface DatasetIdentifier {
    datasetName: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         itemIds: ["item_ids"]
 *     }
 */
interface DatasetItemsDelete {
    itemIds: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         experimentIds: "experiment_ids"
 *     }
 */
interface FindDatasetItemsWithExperimentItemsRequest {
    page?: number;
    size?: number;
    experimentIds: string;
    filters?: string;
    truncate?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         datasetName: "dataset_name"
 *     }
 */
interface DatasetIdentifierPublic {
    datasetName: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetDatasetItemsRequest {
    page?: number;
    size?: number;
    truncate?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetDatasetItemsOutputColumnsRequest {
    experimentIds?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface DatasetItemStreamRequest {
    datasetName: string;
    lastRetrievedId?: string;
    steamLimit?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindExperimentsRequest {
    page?: number;
    size?: number;
    datasetId?: string;
    name?: string;
    datasetDeleted?: boolean;
    promptId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         datasetName: "dataset_name"
 *     }
 */
interface ExperimentWrite {
    id?: string;
    datasetName: string;
    name?: string;
    metadata?: JsonNodeWrite;
    promptVersion?: PromptVersionLinkWrite;
    promptVersions?: PromptVersionLinkWrite[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         experimentItems: [{
 *                 experimentId: "experiment_id",
 *                 datasetItemId: "dataset_item_id",
 *                 traceId: "trace_id"
 *             }]
 *     }
 */
interface ExperimentItemsBatch {
    experimentItems: ExperimentItem[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         ids: ["ids"]
 *     }
 */
interface ExperimentItemsDelete {
    ids: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         ids: ["ids"]
 *     }
 */
interface ExperimentsDelete {
    ids: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNamesRequest {
    experimentIds?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface IdentifierPublic {
    name: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ExperimentItemStreamRequest {
    experimentName: string;
    limit?: number;
    lastRetrievedId?: string;
    /** Truncate image included in either input, output or metadata */
    truncate?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetTracesByProjectRequest {
    page?: number;
    size?: number;
    projectName?: string;
    projectId?: string;
    filters?: string;
    truncate?: boolean;
    sorting?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         traces: [{
 *                 name: "name",
 *                 startTime: "2024-01-15T09:30:00Z"
 *             }]
 *     }
 */
interface TraceBatchWrite {
    traces: TraceWrite[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {}
 */
interface TraceUpdate {
    /** If null and project_id not specified, Default Project is assumed */
    projectName?: string;
    /** If null and project_name not specified, Default Project is assumed */
    projectId?: string;
    endTime?: Date;
    input?: JsonNode;
    output?: JsonNode;
    metadata?: JsonNode;
    tags?: string[];
    errorInfo?: ErrorInfo;
    threadId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         threadIds: ["thread_ids"]
 *     }
 */
interface DeleteTraceThreads {
    /** If null, project_id must be provided */
    projectName?: string;
    /** If null, project_name must be provided */
    projectId?: string;
    threadIds: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNames2Request {
    projectId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetTraceStatsRequest {
    projectId?: string;
    projectName?: string;
    filters?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {
 *         projectId: "project_id",
 *         threadId: "thread_id"
 *     }
 */
interface TraceThreadIdentifier {
    projectId: string;
    threadId: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * @example
 *     {}
 */
interface GetTraceThreadsRequest {
    page?: number;
    size?: number;
    projectName?: string;
    projectId?: string;
    truncate?: boolean;
    filters?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface BiInformation {
    workspaceId?: string;
    user?: string;
    count?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface BiInformationResponse {
    biInformation?: BiInformation[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface TraceCountResponse {
    workspacesTracesCount?: WorkspaceTraceCount[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface WorkspaceTraceCount {
    workspace?: string;
    traceCount?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type AuthDetailsHolder = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface BatchDelete {
    ids: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface AutomationRuleEvaluatorPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: unknown[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type LogItemLevel = "INFO" | "WARN" | "ERROR" | "DEBUG" | "TRACE";
declare const LogItemLevel: {
    readonly Info: "INFO";
    readonly Warn: "WARN";
    readonly Error: "ERROR";
    readonly Debug: "DEBUG";
    readonly Trace: "TRACE";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface LogItem {
    timestamp?: Date;
    ruleId?: string;
    level?: LogItemLevel;
    message?: string;
    markers?: Record<string, string>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface LogPage {
    content?: LogItem[];
    page?: number;
    size?: number;
    total?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type AssistantMessageRole = "system" | "user" | "assistant" | "tool" | "function";
declare const AssistantMessageRole: {
    readonly System: "system";
    readonly User: "user";
    readonly Assistant: "assistant";
    readonly Tool: "tool";
    readonly Function: "function";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface AssistantMessage {
    role?: AssistantMessageRole;
    content?: string;
    name?: string;
    toolCalls?: ToolCall[];
    refusal?: boolean;
    functionCall?: FunctionCall;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ChatCompletionChoice {
    index?: number;
    message?: AssistantMessage;
    delta?: Delta;
    finishReason?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ChatCompletionResponse {
    id?: string;
    created?: number;
    model?: string;
    choices?: ChatCompletionChoice[];
    usage?: Usage;
    systemFingerprint?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CompletionTokensDetails {
    reasoningTokens?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type DeltaRole = "system" | "user" | "assistant" | "tool" | "function";
declare const DeltaRole: {
    readonly System: "system";
    readonly User: "user";
    readonly Assistant: "assistant";
    readonly Tool: "tool";
    readonly Function: "function";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Delta {
    role?: DeltaRole;
    content?: string;
    toolCalls?: ToolCall[];
    functionCall?: FunctionCall;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface FunctionCall {
    name?: string;
    arguments?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ToolCall {
    id?: string;
    index?: number;
    type?: "function";
    function?: FunctionCall;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Usage {
    totalTokens?: number;
    promptTokens?: number;
    completionTokens?: number;
    completionTokensDetails?: CompletionTokensDetails;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Function {
    name?: string;
    description?: string;
    strict?: boolean;
    parameters?: JsonObjectSchema;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface JsonObjectSchema {
    type?: string;
    description?: string;
    properties?: Record<string, JsonSchemaElement>;
    required?: string[];
    additionalProperties?: boolean;
    defs?: Record<string, JsonSchemaElement>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface JsonSchema {
    name?: string;
    strict?: boolean;
    schema?: JsonObjectSchema;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface JsonSchemaElement {
    type?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type Message = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ResponseFormatType = "text" | "json_object" | "json_schema";
declare const ResponseFormatType: {
    readonly Text: "text";
    readonly JsonObject: "json_object";
    readonly JsonSchema: "json_schema";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ResponseFormat {
    type?: ResponseFormatType;
    jsonSchema?: JsonSchema;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface StreamOptions {
    includeUsage?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Tool {
    type?: "function";
    function?: Function;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface Comment {
    id?: string;
    text: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ExperimentItem {
    id?: string;
    experimentId: string;
    datasetItemId: string;
    traceId: string;
    input?: JsonNode;
    output?: JsonNode;
    feedbackScores?: FeedbackScore[];
    comments?: Comment[];
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type FeedbackScoreSource = "ui" | "sdk" | "online_scoring";
declare const FeedbackScoreSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackScore {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type JsonNode = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type DatasetItemWriteSource = "manual" | "trace" | "span" | "sdk";
declare const DatasetItemWriteSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface DatasetItemWrite {
    id?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemWriteSource;
    data: JsonNode;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ColumnCompareTypesItem = "string" | "number" | "object" | "boolean" | "array" | "null";
declare const ColumnCompareTypesItem: {
    readonly String: "string";
    readonly Number: "number";
    readonly Object: "object";
    readonly Boolean: "boolean";
    readonly Array: "array";
    readonly Null: "null";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ColumnCompare {
    name?: string;
    types?: ColumnCompareTypesItem[];
    filterFieldPrefix?: string;
    /** The field to use for filtering */
    filterField?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CommentCompare {
    id?: string;
    text: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface DatasetItemPageCompare {
    content?: DatasetItemCompare[];
    page?: number;
    size?: number;
    total?: number;
    columns?: ColumnCompare[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type DatasetItemCompareSource = "manual" | "trace" | "span" | "sdk";
declare const DatasetItemCompareSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface DatasetItemCompare {
    id?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemCompareSource;
    data: JsonNode;
    experimentItems?: ExperimentItemCompare[];
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ExperimentItemCompare {
    id?: string;
    experimentId: string;
    datasetItemId: string;
    traceId: string;
    input?: JsonNodeCompare;
    output?: JsonNodeCompare;
    feedbackScores?: FeedbackScoreCompare[];
    comments?: CommentCompare[];
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type FeedbackScoreCompareSource = "ui" | "sdk" | "online_scoring";
declare const FeedbackScoreCompareSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackScoreCompare {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreCompareSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type JsonNodeCompare = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface DatasetPagePublic {
    content?: DatasetPublic[];
    page?: number;
    size?: number;
    total?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface DatasetPublic {
    id?: string;
    name: string;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    experimentCount?: number;
    datasetItemsCount?: number;
    mostRecentExperimentAt?: Date;
    lastCreatedExperimentAt?: Date;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type DatasetItemPublicSource = "manual" | "trace" | "span" | "sdk";
declare const DatasetItemPublicSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface DatasetItemPublic {
    id?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemPublicSource;
    data: JsonNode;
    experimentItems?: ExperimentItemPublic[];
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ExperimentItemPublic {
    id?: string;
    experimentId: string;
    datasetItemId: string;
    traceId: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ColumnPublicTypesItem = "string" | "number" | "object" | "boolean" | "array" | "null";
declare const ColumnPublicTypesItem: {
    readonly String: "string";
    readonly Number: "number";
    readonly Object: "object";
    readonly Boolean: "boolean";
    readonly Array: "array";
    readonly Null: "null";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ColumnPublic {
    name?: string;
    types?: ColumnPublicTypesItem[];
    filterFieldPrefix?: string;
    /** The field to use for filtering */
    filterField?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface DatasetItemPagePublic {
    content?: DatasetItemPublic[];
    page?: number;
    size?: number;
    total?: number;
    columns?: ColumnPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ColumnTypesItem = "string" | "number" | "object" | "boolean" | "array" | "null";
declare const ColumnTypesItem: {
    readonly String: "string";
    readonly Number: "number";
    readonly Object: "object";
    readonly Boolean: "boolean";
    readonly Array: "array";
    readonly Null: "null";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Column {
    name?: string;
    types?: ColumnTypesItem[];
    filterFieldPrefix?: string;
    /** The field to use for filtering */
    filterField?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PageColumns {
    columns?: Column[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface FeedbackScoreAverage {
    name: string;
    value: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type JsonNodeWrite = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface PromptVersionLinkWrite {
    id: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CommentPublic {
    id?: string;
    text: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ExperimentPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: ExperimentPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ExperimentPublic {
    id?: string;
    datasetName: string;
    datasetId?: string;
    name?: string;
    metadata?: JsonNodePublic;
    feedbackScores?: FeedbackScoreAveragePublic[];
    comments?: CommentPublic[];
    traceCount?: number;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    promptVersion?: PromptVersionLinkPublic;
    promptVersions?: PromptVersionLinkPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface FeedbackScoreAveragePublic {
    name: string;
    value: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type JsonNodePublic = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface PromptVersionLinkPublic {
    id: string;
    commit?: string;
    promptId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface CategoricalFeedbackDefinitionCreate {
    details?: CategoricalFeedbackDetailCreate;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CategoricalFeedbackDetailCreate {
    categories: Record<string, number>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

type FeedbackCreate = FeedbackCreate.Numerical | FeedbackCreate.Categorical;
declare namespace FeedbackCreate {
    interface Numerical extends NumericalFeedbackDefinitionCreate, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionCreate, _Base {
        type: "categorical";
    }
    interface _Base {
        id?: string;
        name: string;
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface NumericalFeedbackDefinitionCreate {
    details?: NumericalFeedbackDetailCreate;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface NumericalFeedbackDetailCreate {
    max: number;
    min: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface CategoricalFeedbackDefinitionPublic {
    details?: CategoricalFeedbackDetailPublic;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CategoricalFeedbackDetailPublic {
    categories: Record<string, number>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackDefinitionPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: FeedbackObjectPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

type FeedbackObjectPublic = FeedbackObjectPublic.Numerical | FeedbackObjectPublic.Categorical;
declare namespace FeedbackObjectPublic {
    interface Numerical extends NumericalFeedbackDefinitionPublic, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionPublic, _Base {
        type: "categorical";
    }
    interface _Base {
        id?: string;
        name: string;
        createdAt?: Date;
        createdBy?: string;
        lastUpdatedAt?: Date;
        lastUpdatedBy?: string;
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface NumericalFeedbackDefinitionPublic {
    details?: NumericalFeedbackDetailPublic;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface NumericalFeedbackDetailPublic {
    max: number;
    min: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

type FeedbackPublic = FeedbackPublic.Numerical | FeedbackPublic.Categorical;
declare namespace FeedbackPublic {
    interface Numerical extends NumericalFeedbackDefinitionPublic, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionPublic, _Base {
        type: "categorical";
    }
    interface _Base {
        id?: string;
        name: string;
        createdAt?: Date;
        createdBy?: string;
        lastUpdatedAt?: Date;
        lastUpdatedBy?: string;
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface CategoricalFeedbackDefinitionUpdate {
    details?: CategoricalFeedbackDetailUpdate;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CategoricalFeedbackDetailUpdate {
    categories: Record<string, number>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

type FeedbackUpdate = FeedbackUpdate.Numerical | FeedbackUpdate.Categorical;
declare namespace FeedbackUpdate {
    interface Numerical extends NumericalFeedbackDefinitionUpdate, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionUpdate, _Base {
        type: "categorical";
    }
    interface _Base {
        id?: string;
        name: string;
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface NumericalFeedbackDefinitionUpdate {
    details?: NumericalFeedbackDetailUpdate;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface NumericalFeedbackDetailUpdate {
    max: number;
    min: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProjectPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: ProjectPublic[];
    sortableBy?: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ProviderApiKeyPublicProvider = "openai" | "anthropic" | "gemini" | "openrouter";
declare const ProviderApiKeyPublicProvider: {
    readonly Openai: "openai";
    readonly Anthropic: "anthropic";
    readonly Gemini: "gemini";
    readonly Openrouter: "openrouter";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProviderApiKeyPublic {
    id?: string;
    provider: ProviderApiKeyPublicProvider;
    apiKey: string;
    name?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface PercentageValues {
    p50?: number;
    p90?: number;
    p99?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ProjectPublic {
    id?: string;
    name: string;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    lastUpdatedTraceAt?: Date;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackScoreNames {
    scores?: ScoreName[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ScoreName {
    name?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface DataPointNumberPublic {
    time: Date;
    value?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ProjectMetricResponsePublicMetricType = "FEEDBACK_SCORES" | "TRACE_COUNT" | "TOKEN_USAGE" | "DURATION" | "COST";
declare const ProjectMetricResponsePublicMetricType: {
    readonly FeedbackScores: "FEEDBACK_SCORES";
    readonly TraceCount: "TRACE_COUNT";
    readonly TokenUsage: "TOKEN_USAGE";
    readonly Duration: "DURATION";
    readonly Cost: "COST";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type ProjectMetricResponsePublicInterval = "HOURLY" | "DAILY" | "WEEKLY";
declare const ProjectMetricResponsePublicInterval: {
    readonly Hourly: "HOURLY";
    readonly Daily: "DAILY";
    readonly Weekly: "WEEKLY";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProjectMetricResponsePublic {
    projectId?: string;
    metricType?: ProjectMetricResponsePublicMetricType;
    interval?: ProjectMetricResponsePublicInterval;
    results?: ResultsNumberPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ResultsNumberPublic {
    name?: string;
    data?: DataPointNumberPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProjectStatsSummary {
    content?: ProjectStatsSummaryItem[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProjectStatsSummaryItem {
    projectId?: string;
    feedbackScores?: FeedbackScoreAverage[];
    duration?: PercentageValues;
    totalEstimatedCost?: number;
    usage?: Record<string, number>;
    traceCount?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface FeedbackScoreAverageDetailed {
    name: string;
    value: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface PercentageValuesDetailed {
    p50?: number;
    p90?: number;
    p99?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProjectDetailed {
    id?: string;
    name: string;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    lastUpdatedTraceAt?: Date;
    feedbackScores?: FeedbackScoreAverageDetailed[];
    duration?: PercentageValuesDetailed;
    totalEstimatedCost?: number;
    usage?: Record<string, number>;
    traceCount?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type JsonNodeDetail = Record<string, unknown>;

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type PromptVersionDetailType = "mustache" | "jinja2";
declare const PromptVersionDetailType: {
    readonly Mustache: "mustache";
    readonly Jinja2: "jinja2";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PromptVersionDetail {
    /** version unique identifier, generated if absent */
    id?: string;
    promptId?: string;
    /** version short unique identifier, generated if absent. it must be 8 characters long */
    commit?: string;
    template: string;
    metadata?: JsonNodeDetail;
    type?: PromptVersionDetailType;
    changeDescription?: string;
    variables?: string[];
    createdAt?: Date;
    createdBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PromptDetail {
    id?: string;
    name: string;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    versionCount?: number;
    latestVersion?: PromptVersionDetail;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PromptVersionPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: PromptVersionPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type PromptVersionPublicType = "mustache" | "jinja2";
declare const PromptVersionPublicType: {
    readonly Mustache: "mustache";
    readonly Jinja2: "jinja2";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PromptVersionPublic {
    /** version unique identifier, generated if absent */
    id?: string;
    promptId?: string;
    /** version short unique identifier, generated if absent. it must be 8 characters long */
    commit?: string;
    template: string;
    metadata?: JsonNodePublic;
    type?: PromptVersionPublicType;
    changeDescription?: string;
    createdAt?: Date;
    createdBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PromptPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: PromptPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface PromptPublic {
    id?: string;
    name: string;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    versionCount?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ErrorInfo {
    exceptionType: string;
    message?: string;
    traceback: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type SpanType = "general" | "tool" | "llm";
declare const SpanType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Span$1 {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    traceId: string;
    parentSpanId?: string;
    name: string;
    type: SpanType;
    startTime: Date;
    endTime?: Date;
    input?: JsonNode;
    output?: JsonNode;
    metadata?: JsonNode;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfo;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScore[];
    comments?: Comment[];
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ErrorInfoWrite {
    exceptionType: string;
    message?: string;
    traceback: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type SpanWriteType = "general" | "tool" | "llm";
declare const SpanWriteType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface SpanWrite {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    traceId: string;
    parentSpanId?: string;
    name: string;
    type: SpanWriteType;
    startTime: Date;
    endTime?: Date;
    input?: JsonNodeWrite;
    output?: JsonNodeWrite;
    metadata?: JsonNodeWrite;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfoWrite;
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface DeleteFeedbackScore {
    name: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface ErrorInfoPublic {
    exceptionType: string;
    message?: string;
    traceback: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type FeedbackScorePublicSource = "ui" | "sdk" | "online_scoring";
declare const FeedbackScorePublicSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackScorePublic {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScorePublicSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type SpanPublicType = "general" | "tool" | "llm";
declare const SpanPublicType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface SpanPublic {
    id?: string;
    projectId?: string;
    traceId: string;
    parentSpanId?: string;
    name: string;
    type: SpanPublicType;
    startTime: Date;
    endTime?: Date;
    input?: JsonNodePublic;
    output?: JsonNodePublic;
    metadata?: JsonNodePublic;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfoPublic;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScorePublic[];
    comments?: CommentPublic[];
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface SpanPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: SpanPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface AvgValueStatPublic {
    value?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface CountValueStatPublic {
    value?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface PercentageValueStatPublic {
    value?: PercentageValuesPublic;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface PercentageValuesPublic {
    p50?: number;
    p90?: number;
    p99?: number;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

type ProjectStatItemObjectPublic = ProjectStatItemObjectPublic.Percentage | ProjectStatItemObjectPublic.Count | ProjectStatItemObjectPublic.Avg;
declare namespace ProjectStatItemObjectPublic {
    interface Percentage extends PercentageValueStatPublic, _Base {
        type: "PERCENTAGE";
    }
    interface Count extends CountValueStatPublic, _Base {
        type: "COUNT";
    }
    interface Avg extends AvgValueStatPublic, _Base {
        type: "AVG";
    }
    interface _Base {
        name?: string;
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface ProjectStatsPublic {
    stats?: ProjectStatItemObjectPublic[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackScoreBatch {
    scores: FeedbackScoreBatchItem[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type FeedbackScoreBatchItemSource = "ui" | "sdk" | "online_scoring";
declare const FeedbackScoreBatchItemSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface FeedbackScoreBatchItem {
    id: string;
    /** If null, the default project is used */
    projectName?: string;
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreBatchItemSource;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
type SpanFilterPublicOperator = "contains" | "not_contains" | "starts_with" | "ends_with" | "=" | "!=" | ">" | ">=" | "<" | "<=";
declare const SpanFilterPublicOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface SpanFilterPublic {
    field?: string;
    operator?: SpanFilterPublicOperator;
    key?: string;
    value?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface Trace$1 {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    name: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonNode;
    output?: JsonNode;
    metadata?: JsonNode;
    tags?: string[];
    errorInfo?: ErrorInfo;
    usage?: Record<string, number>;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScore[];
    comments?: Comment[];
    totalEstimatedCost?: number;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
    threadId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface TraceWrite {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    name: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonNodeWrite;
    output?: JsonNodeWrite;
    metadata?: JsonNodeWrite;
    tags?: string[];
    errorInfo?: ErrorInfoWrite;
    threadId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface TracePublic {
    id?: string;
    projectId?: string;
    name: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonNodePublic;
    output?: JsonNodePublic;
    metadata?: JsonNodePublic;
    tags?: string[];
    errorInfo?: ErrorInfoPublic;
    usage?: Record<string, number>;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScorePublic[];
    comments?: CommentPublic[];
    totalEstimatedCost?: number;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
    threadId?: string;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface TraceThread {
    id?: string;
    projectId?: string;
    startTime?: Date;
    endTime?: Date;
    duration?: number;
    firstMessage?: JsonNode;
    lastMessage?: JsonNode;
    numberOfMessages?: number;
    lastUpdatedAt?: Date;
    createdBy?: string;
    createdAt?: Date;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface TraceThreadPage {
    page?: number;
    size?: number;
    total?: number;
    content?: TraceThread[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

interface TracePagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: TracePublic[];
    sortableBy?: string[];
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
interface WorkspaceMetadata {
    traceDynamicSortingEnabled?: boolean;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
declare const OpikApiEnvironment: {
    readonly Default: "http://localhost:5173/api";
};
type OpikApiEnvironment = typeof OpikApiEnvironment.Default;

type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
declare const Supplier: {
    get: <T>(supplier: Supplier<T>) => Promise<T>;
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace SystemUsage {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * System usage related resource
 */
declare class SystemUsage {
    protected readonly _options: SystemUsage.Options;
    constructor(_options?: SystemUsage.Options);
    /**
     * Get datasets information for BI events per user per workspace
     *
     * @param {SystemUsage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getDatasetBiInfo()
     */
    getDatasetBiInfo(requestOptions?: SystemUsage.RequestOptions): Promise<BiInformationResponse>;
    /**
     * Get experiments information for BI events per user per workspace
     *
     * @param {SystemUsage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getExperimentBiInfo()
     */
    getExperimentBiInfo(requestOptions?: SystemUsage.RequestOptions): Promise<BiInformationResponse>;
    /**
     * Get traces information for BI events per user per workspace
     *
     * @param {SystemUsage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getTracesBiInfo()
     */
    getTracesBiInfo(requestOptions?: SystemUsage.RequestOptions): Promise<BiInformationResponse>;
    /**
     * Get traces count on previous day for all available workspaces
     *
     * @param {SystemUsage.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getTracesCountForWorkspaces()
     */
    getTracesCountForWorkspaces(requestOptions?: SystemUsage.RequestOptions): Promise<TraceCountResponse>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Check {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Access check resources
 */
declare class Check {
    protected readonly _options: Check.Options;
    constructor(_options?: Check.Options);
    /**
     * Check user access to workspace
     *
     * @param {OpikApi.AuthDetailsHolder} request
     * @param {Check.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.check.access({
     *         "key": "value"
     *     })
     */
    access(request: AuthDetailsHolder, requestOptions?: Check.RequestOptions): Promise<void>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace AutomationRuleEvaluators {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Automation rule evaluators resource
 */
declare class AutomationRuleEvaluators {
    protected readonly _options: AutomationRuleEvaluators.Options;
    constructor(_options?: AutomationRuleEvaluators.Options);
    /**
     * Find project Evaluators
     *
     * @param {OpikApi.FindEvaluatorsRequest} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.findEvaluators()
     */
    findEvaluators(request?: FindEvaluatorsRequest, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<AutomationRuleEvaluatorPagePublic>;
    /**
     * Create automation rule evaluator
     *
     * @param {unknown} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.createAutomationRuleEvaluator({
     *         "key": "value"
     *     })
     */
    createAutomationRuleEvaluator(request?: unknown, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<void>;
    /**
     * Delete automation rule evaluators batch
     *
     * @param {OpikApi.DeleteAutomationRuleEvaluatorBatchRequest} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.deleteAutomationRuleEvaluatorBatch({
     *         projectId: "project_id",
     *         body: {
     *             ids: ["ids"]
     *         }
     *     })
     */
    deleteAutomationRuleEvaluatorBatch(request: DeleteAutomationRuleEvaluatorBatchRequest, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<void>;
    /**
     * Get automation rule by id
     *
     * @param {string} id
     * @param {OpikApi.GetEvaluatorByIdRequest} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.getEvaluatorById("id")
     */
    getEvaluatorById(id: string, request?: GetEvaluatorByIdRequest, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<unknown>;
    /**
     * Update Automation Rule Evaluator by id
     *
     * @param {string} id
     * @param {unknown} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.updateAutomationRuleEvaluator("id", {
     *         "key": "value"
     *     })
     */
    updateAutomationRuleEvaluator(id: string, request?: unknown, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<void>;
    /**
     * Get automation rule evaluator logs by id
     *
     * @param {string} id
     * @param {OpikApi.GetEvaluatorLogsByIdRequest} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.getEvaluatorLogsById("id")
     */
    getEvaluatorLogsById(id: string, request?: GetEvaluatorLogsByIdRequest, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<LogPage>;
    /**
     * Find project Evaluators Deprecated
     *
     * @param {string} projectId
     * @param {OpikApi.FindEvaluatorsDeprecatedRequest} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.findEvaluatorsDeprecated("projectId")
     */
    findEvaluatorsDeprecated(projectId: string, request?: FindEvaluatorsDeprecatedRequest, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<AutomationRuleEvaluatorPagePublic>;
    /**
     * Create automation rule evaluator Deprecated
     *
     * @param {string} projectId
     * @param {unknown} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.createAutomationRuleEvaluatorDeprecated("projectId", {
     *         "key": "value"
     *     })
     */
    createAutomationRuleEvaluatorDeprecated(projectId: string, request?: unknown, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<void>;
    /**
     * Delete automation rule evaluators batch Deprecated
     *
     * @param {string} projectId
     * @param {OpikApi.BatchDelete} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.deleteAutomationRuleEvaluatorBatchDeprecated("projectId", {
     *         ids: ["ids"]
     *     })
     */
    deleteAutomationRuleEvaluatorBatchDeprecated(projectId: string, request: BatchDelete, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<void>;
    /**
     * Get automation rule by id Deprecated
     *
     * @param {string} projectId
     * @param {string} id
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.getEvaluatorByIdDeprecated("projectId", "id")
     */
    getEvaluatorByIdDeprecated(projectId: string, id: string, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<unknown>;
    /**
     * update Automation Rule Evaluator by id Deprecated
     *
     * @param {string} id
     * @param {string} projectId
     * @param {unknown} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.updateAutomationRuleEvaluatorDeprecated("id", "projectId", {
     *         "key": "value"
     *     })
     */
    updateAutomationRuleEvaluatorDeprecated(id: string, projectId: string, request?: unknown, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<void>;
    /**
     * Get automation rule evaluator logs by id Deprecated
     *
     * @param {string} projectId
     * @param {string} id
     * @param {OpikApi.GetEvaluatorLogsByIdDeprecatedRequest} request
     * @param {AutomationRuleEvaluators.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.getEvaluatorLogsByIdDeprecated("projectId", "id")
     */
    getEvaluatorLogsByIdDeprecated(projectId: string, id: string, request?: GetEvaluatorLogsByIdDeprecatedRequest, requestOptions?: AutomationRuleEvaluators.RequestOptions): Promise<LogPage>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace ChatCompletions {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Chat Completions related resources
 */
declare class ChatCompletions {
    protected readonly _options: ChatCompletions.Options;
    constructor(_options?: ChatCompletions.Options);
    /**
     * Create chat completions
     *
     * @param {OpikApi.ChatCompletionRequest} request
     * @param {ChatCompletions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chatCompletions.createChatCompletions()
     */
    createChatCompletions(request?: ChatCompletionRequest, requestOptions?: ChatCompletions.RequestOptions): Promise<ChatCompletionResponse>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Datasets {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Dataset resources
 */
declare class Datasets {
    protected readonly _options: Datasets.Options;
    constructor(_options?: Datasets.Options);
    /**
     * Find datasets
     *
     * @param {OpikApi.FindDatasetsRequest} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.findDatasets()
     */
    findDatasets(request?: FindDatasetsRequest, requestOptions?: Datasets.RequestOptions): Promise<DatasetPagePublic>;
    /**
     * Create dataset
     *
     * @param {OpikApi.DatasetWrite} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDataset({
     *         name: "name"
     *     })
     */
    createDataset(request: DatasetWrite, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Create/update dataset items based on dataset item id
     *
     * @param {OpikApi.DatasetItemBatchWrite} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createOrUpdateDatasetItems({
     *         items: [{
     *                 source: "manual",
     *                 data: {
     *                     "key": "value"
     *                 }
     *             }]
     *     })
     */
    createOrUpdateDatasetItems(request: DatasetItemBatchWrite, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Get dataset by id
     *
     * @param {string} id
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetById("id")
     */
    getDatasetById(id: string, requestOptions?: Datasets.RequestOptions): Promise<DatasetPublic>;
    /**
     * Update dataset by id
     *
     * @param {string} id
     * @param {OpikApi.DatasetUpdate} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.updateDataset("id", {
     *         name: "name"
     *     })
     */
    updateDataset(id: string, request: DatasetUpdate, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Delete dataset by id
     *
     * @param {string} id
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDataset("id")
     */
    deleteDataset(id: string, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Delete dataset by name
     *
     * @param {OpikApi.DatasetIdentifier} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetByName({
     *         datasetName: "dataset_name"
     *     })
     */
    deleteDatasetByName(request: DatasetIdentifier, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Delete dataset items
     *
     * @param {OpikApi.DatasetItemsDelete} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetItems({
     *         itemIds: ["item_ids"]
     *     })
     */
    deleteDatasetItems(request: DatasetItemsDelete, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Delete datasets batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteDatasetsBatch(request: BatchDelete, requestOptions?: Datasets.RequestOptions): Promise<void>;
    /**
     * Find dataset items with experiment items
     *
     * @param {string} id
     * @param {OpikApi.FindDatasetItemsWithExperimentItemsRequest} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.findDatasetItemsWithExperimentItems("id", {
     *         experimentIds: "experiment_ids"
     *     })
     */
    findDatasetItemsWithExperimentItems(id: string, request: FindDatasetItemsWithExperimentItemsRequest, requestOptions?: Datasets.RequestOptions): Promise<DatasetItemPageCompare>;
    /**
     * Get dataset by name
     *
     * @param {OpikApi.DatasetIdentifierPublic} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetByIdentifier({
     *         datasetName: "dataset_name"
     *     })
     */
    getDatasetByIdentifier(request: DatasetIdentifierPublic, requestOptions?: Datasets.RequestOptions): Promise<DatasetPublic>;
    /**
     * Get dataset item by id
     *
     * @param {string} itemId
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItemById("itemId")
     */
    getDatasetItemById(itemId: string, requestOptions?: Datasets.RequestOptions): Promise<DatasetItemPublic>;
    /**
     * Get dataset items
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetItemsRequest} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItems("id")
     */
    getDatasetItems(id: string, request?: GetDatasetItemsRequest, requestOptions?: Datasets.RequestOptions): Promise<DatasetItemPagePublic>;
    /**
     * Get dataset items output columns
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetItemsOutputColumnsRequest} request
     * @param {Datasets.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItemsOutputColumns("id")
     */
    getDatasetItemsOutputColumns(id: string, request?: GetDatasetItemsOutputColumnsRequest, requestOptions?: Datasets.RequestOptions): Promise<PageColumns>;
    /**
     * Stream dataset items
     */
    streamDatasetItems(request: DatasetItemStreamRequest, requestOptions?: Datasets.RequestOptions): Promise<stream.Readable>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Experiments {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Experiment resources
 */
declare class Experiments {
    protected readonly _options: Experiments.Options;
    constructor(_options?: Experiments.Options);
    /**
     * Find experiments
     *
     * @param {OpikApi.FindExperimentsRequest} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.findExperiments()
     */
    findExperiments(request?: FindExperimentsRequest, requestOptions?: Experiments.RequestOptions): Promise<ExperimentPagePublic>;
    /**
     * Create experiment
     *
     * @param {OpikApi.ExperimentWrite} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.createExperiment({
     *         datasetName: "dataset_name"
     *     })
     */
    createExperiment(request: ExperimentWrite, requestOptions?: Experiments.RequestOptions): Promise<void>;
    /**
     * Create experiment items
     *
     * @param {OpikApi.ExperimentItemsBatch} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.createExperimentItems({
     *         experimentItems: [{
     *                 experimentId: "experiment_id",
     *                 datasetItemId: "dataset_item_id",
     *                 traceId: "trace_id"
     *             }]
     *     })
     */
    createExperimentItems(request: ExperimentItemsBatch, requestOptions?: Experiments.RequestOptions): Promise<void>;
    /**
     * Delete experiment items
     *
     * @param {OpikApi.ExperimentItemsDelete} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.deleteExperimentItems({
     *         ids: ["ids"]
     *     })
     */
    deleteExperimentItems(request: ExperimentItemsDelete, requestOptions?: Experiments.RequestOptions): Promise<void>;
    /**
     * Delete experiments by id
     *
     * @param {OpikApi.ExperimentsDelete} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.deleteExperimentsById({
     *         ids: ["ids"]
     *     })
     */
    deleteExperimentsById(request: ExperimentsDelete, requestOptions?: Experiments.RequestOptions): Promise<void>;
    /**
     * Find Feedback Score names
     *
     * @param {OpikApi.FindFeedbackScoreNamesRequest} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.findFeedbackScoreNames()
     */
    findFeedbackScoreNames(request?: FindFeedbackScoreNamesRequest, requestOptions?: Experiments.RequestOptions): Promise<string[]>;
    /**
     * Get experiment by id
     *
     * @param {string} id
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.experiments.getExperimentById("id")
     */
    getExperimentById(id: string, requestOptions?: Experiments.RequestOptions): Promise<ExperimentPublic>;
    /**
     * Get experiment by name
     *
     * @param {OpikApi.IdentifierPublic} request
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.experiments.getExperimentByName({
     *         name: "name"
     *     })
     */
    getExperimentByName(request: IdentifierPublic, requestOptions?: Experiments.RequestOptions): Promise<ExperimentPublic>;
    /**
     * Get experiment item by id
     *
     * @param {string} id
     * @param {Experiments.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.experiments.getExperimentItemById("id")
     */
    getExperimentItemById(id: string, requestOptions?: Experiments.RequestOptions): Promise<ExperimentItemPublic>;
    /**
     * Stream experiment items
     */
    streamExperimentItems(request: ExperimentItemStreamRequest, requestOptions?: Experiments.RequestOptions): Promise<stream.Readable>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace FeedbackDefinitions {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Feedback definitions related resources
 */
declare class FeedbackDefinitions {
    protected readonly _options: FeedbackDefinitions.Options;
    constructor(_options?: FeedbackDefinitions.Options);
    /**
     * Find Feedback definitions
     *
     * @param {OpikApi.FindFeedbackDefinitionsRequest} request
     * @param {FeedbackDefinitions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.findFeedbackDefinitions()
     */
    findFeedbackDefinitions(request?: FindFeedbackDefinitionsRequest, requestOptions?: FeedbackDefinitions.RequestOptions): Promise<FeedbackDefinitionPagePublic>;
    /**
     * Get feedback definition
     *
     * @param {OpikApi.FeedbackCreate} request
     * @param {FeedbackDefinitions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.createFeedbackDefinition({
     *         type: "categorical"
     *     })
     */
    createFeedbackDefinition(request: FeedbackCreate, requestOptions?: FeedbackDefinitions.RequestOptions): Promise<void>;
    /**
     * Get feedback definition by id
     *
     * @param {string} id
     * @param {FeedbackDefinitions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.getFeedbackDefinitionById("id")
     */
    getFeedbackDefinitionById(id: string, requestOptions?: FeedbackDefinitions.RequestOptions): Promise<FeedbackPublic>;
    /**
     * Update feedback definition by id
     *
     * @param {string} id
     * @param {OpikApi.FeedbackUpdate} request
     * @param {FeedbackDefinitions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.updateFeedbackDefinition("id", {
     *         type: "categorical"
     *     })
     */
    updateFeedbackDefinition(id: string, request: FeedbackUpdate, requestOptions?: FeedbackDefinitions.RequestOptions): Promise<void>;
    /**
     * Delete feedback definition by id
     *
     * @param {string} id
     * @param {FeedbackDefinitions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.deleteFeedbackDefinitionById("id")
     */
    deleteFeedbackDefinitionById(id: string, requestOptions?: FeedbackDefinitions.RequestOptions): Promise<void>;
    /**
     * Delete feedback definitions batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {FeedbackDefinitions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.deleteFeedbackDefinitionsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteFeedbackDefinitionsBatch(request: BatchDelete, requestOptions?: FeedbackDefinitions.RequestOptions): Promise<void>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace LlmProviderKey {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * LLM Provider Key
 */
declare class LlmProviderKey {
    protected readonly _options: LlmProviderKey.Options;
    constructor(_options?: LlmProviderKey.Options);
    /**
     * Delete LLM Provider's ApiKeys batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {LlmProviderKey.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.llmProviderKey.deleteLlmProviderApiKeysBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteLlmProviderApiKeysBatch(request: BatchDelete, requestOptions?: LlmProviderKey.RequestOptions): Promise<void>;
    /**
     * Find LLM Provider's ApiKeys
     *
     * @param {LlmProviderKey.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.llmProviderKey.findLlmProviderKeys()
     */
    findLlmProviderKeys(requestOptions?: LlmProviderKey.RequestOptions): Promise<ProjectPagePublic>;
    /**
     * Store LLM Provider's ApiKey
     *
     * @param {OpikApi.ProviderApiKeyWrite} request
     * @param {LlmProviderKey.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.llmProviderKey.storeLlmProviderApiKey({
     *         provider: "openai",
     *         apiKey: "api_key"
     *     })
     */
    storeLlmProviderApiKey(request: ProviderApiKeyWrite, requestOptions?: LlmProviderKey.RequestOptions): Promise<void>;
    /**
     * Get LLM Provider's ApiKey by id
     *
     * @param {string} id
     * @param {LlmProviderKey.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.llmProviderKey.getLlmProviderApiKeyById("id")
     */
    getLlmProviderApiKeyById(id: string, requestOptions?: LlmProviderKey.RequestOptions): Promise<ProviderApiKeyPublic>;
    /**
     * Update LLM Provider's ApiKey
     *
     * @param {string} id
     * @param {OpikApi.ProviderApiKeyUpdate} request
     * @param {LlmProviderKey.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.llmProviderKey.updateLlmProviderApiKey("id", {
     *         apiKey: "api_key"
     *     })
     */
    updateLlmProviderApiKey(id: string, request: ProviderApiKeyUpdate, requestOptions?: LlmProviderKey.RequestOptions): Promise<void>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace OpenTelemetryIngestion {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Resource to ingest Traces and Spans via OpenTelemetry
 */
declare class OpenTelemetryIngestion {
    protected readonly _options: OpenTelemetryIngestion.Options;
    constructor(_options?: OpenTelemetryIngestion.Options);
    /**
     * @param {OpenTelemetryIngestion.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.openTelemetryIngestion.receiveTraces()
     */
    receiveTraces(requestOptions?: OpenTelemetryIngestion.RequestOptions): Promise<unknown>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Projects {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Project related resources
 */
declare class Projects {
    protected readonly _options: Projects.Options;
    constructor(_options?: Projects.Options);
    /**
     * Find projects
     *
     * @param {OpikApi.FindProjectsRequest} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.findProjects()
     */
    findProjects(request?: FindProjectsRequest, requestOptions?: Projects.RequestOptions): Promise<ProjectPagePublic>;
    /**
     * Create project
     *
     * @param {OpikApi.ProjectWrite} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.projects.createProject({
     *         name: "name"
     *     })
     */
    createProject(request: ProjectWrite, requestOptions?: Projects.RequestOptions): Promise<void>;
    /**
     * Get project by id
     *
     * @param {string} id
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.getProjectById("id")
     */
    getProjectById(id: string, requestOptions?: Projects.RequestOptions): Promise<ProjectPublic>;
    /**
     * Delete project by id
     *
     * @param {string} id
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.projects.deleteProjectById("id")
     */
    deleteProjectById(id: string, requestOptions?: Projects.RequestOptions): Promise<void>;
    /**
     * Update project by id
     *
     * @param {string} id
     * @param {OpikApi.ProjectUpdate} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.projects.updateProject("id")
     */
    updateProject(id: string, request?: ProjectUpdate, requestOptions?: Projects.RequestOptions): Promise<void>;
    /**
     * Delete projects batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.deleteProjectsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteProjectsBatch(request: BatchDelete, requestOptions?: Projects.RequestOptions): Promise<void>;
    /**
     * Find Feedback Score names By Project Ids
     *
     * @param {OpikApi.FindFeedbackScoreNamesByProjectIdsRequest} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.findFeedbackScoreNamesByProjectIds()
     */
    findFeedbackScoreNamesByProjectIds(request?: FindFeedbackScoreNamesByProjectIdsRequest, requestOptions?: Projects.RequestOptions): Promise<FeedbackScoreNames>;
    /**
     * Gets specified metrics for a project
     *
     * @param {string} id
     * @param {OpikApi.ProjectMetricRequestPublic} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.projects.getProjectMetrics("id")
     */
    getProjectMetrics(id: string, request?: ProjectMetricRequestPublic, requestOptions?: Projects.RequestOptions): Promise<ProjectMetricResponsePublic>;
    /**
     * Get Project Stats
     *
     * @param {OpikApi.GetProjectStatsRequest} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.getProjectStats()
     */
    getProjectStats(request?: GetProjectStatsRequest, requestOptions?: Projects.RequestOptions): Promise<ProjectStatsSummary>;
    /**
     * Retrieve project
     *
     * @param {OpikApi.ProjectRetrieveDetailed} request
     * @param {Projects.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.projects.retrieveProject({
     *         name: "name"
     *     })
     */
    retrieveProject(request: ProjectRetrieveDetailed, requestOptions?: Projects.RequestOptions): Promise<ProjectDetailed>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Prompts {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Prompt resources
 */
declare class Prompts {
    protected readonly _options: Prompts.Options;
    constructor(_options?: Prompts.Options);
    /**
     * Get prompts
     *
     * @param {OpikApi.GetPromptsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.getPrompts()
     */
    getPrompts(request?: GetPromptsRequest, requestOptions?: Prompts.RequestOptions): Promise<PromptPagePublic>;
    /**
     * Create prompt
     *
     * @param {OpikApi.PromptWrite} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.createPrompt({
     *         name: "name"
     *     })
     */
    createPrompt(request: PromptWrite, requestOptions?: Prompts.RequestOptions): Promise<void>;
    /**
     * Create prompt version
     *
     * @param {OpikApi.CreatePromptVersionDetail} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.createPromptVersion({
     *         name: "name",
     *         version: {
     *             template: "template"
     *         }
     *     })
     */
    createPromptVersion(request: CreatePromptVersionDetail, requestOptions?: Prompts.RequestOptions): Promise<PromptVersionDetail>;
    /**
     * Get prompt by id
     *
     * @param {string} id
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.prompts.getPromptById("id")
     */
    getPromptById(id: string, requestOptions?: Prompts.RequestOptions): Promise<PromptDetail>;
    /**
     * Update prompt
     *
     * @param {string} id
     * @param {OpikApi.PromptUpdatable} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.updatePrompt("id", {
     *         name: "name"
     *     })
     */
    updatePrompt(id: string, request: PromptUpdatable, requestOptions?: Prompts.RequestOptions): Promise<void>;
    /**
     * Delete prompt
     *
     * @param {string} id
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.deletePrompt("id")
     */
    deletePrompt(id: string, requestOptions?: Prompts.RequestOptions): Promise<void>;
    /**
     * Delete prompts batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.deletePromptsBatch({
     *         ids: ["ids"]
     *     })
     */
    deletePromptsBatch(request: BatchDelete, requestOptions?: Prompts.RequestOptions): Promise<void>;
    /**
     * Get prompt version by id
     *
     * @param {string} versionId
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.prompts.getPromptVersionById("versionId")
     */
    getPromptVersionById(versionId: string, requestOptions?: Prompts.RequestOptions): Promise<PromptVersionDetail>;
    /**
     * Get prompt versions
     *
     * @param {string} id
     * @param {OpikApi.GetPromptVersionsRequest} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.getPromptVersions("id")
     */
    getPromptVersions(id: string, request?: GetPromptVersionsRequest, requestOptions?: Prompts.RequestOptions): Promise<PromptVersionPagePublic>;
    /**
     * Retrieve prompt version
     *
     * @param {OpikApi.PromptVersionRetrieveDetail} request
     * @param {Prompts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.retrievePromptVersion({
     *         name: "name"
     *     })
     */
    retrievePromptVersion(request: PromptVersionRetrieveDetail, requestOptions?: Prompts.RequestOptions): Promise<PromptVersionDetail>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Spans {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Span related resources
 */
declare class Spans {
    protected readonly _options: Spans.Options;
    constructor(_options?: Spans.Options);
    /**
     * Add span comment
     *
     * @param {string} id
     * @param {OpikApi.Comment} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.addSpanComment("id", {
     *         text: "text"
     *     })
     */
    addSpanComment(id: string, request: Comment, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Add span feedback score
     *
     * @param {string} id
     * @param {OpikApi.FeedbackScore} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.addSpanFeedbackScore("id", {
     *         name: "name",
     *         value: 1.1,
     *         source: "ui"
     *     })
     */
    addSpanFeedbackScore(id: string, request: FeedbackScore, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Get spans by project_name or project_id and optionally by trace_id and/or type
     *
     * @param {OpikApi.GetSpansByProjectRequest} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.getSpansByProject()
     */
    getSpansByProject(request?: GetSpansByProjectRequest, requestOptions?: Spans.RequestOptions): Promise<SpanPagePublic>;
    /**
     * Create span
     *
     * @param {OpikApi.SpanWrite} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.createSpan({
     *         traceId: "trace_id",
     *         name: "name",
     *         type: "general",
     *         startTime: "2024-01-15T09:30:00Z"
     *     })
     */
    createSpan(request: SpanWrite, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Create spans
     *
     * @param {OpikApi.SpanBatchWrite} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.createSpans({
     *         spans: [{
     *                 traceId: "trace_id",
     *                 name: "name",
     *                 type: "general",
     *                 startTime: "2024-01-15T09:30:00Z"
     *             }]
     *     })
     */
    createSpans(request: SpanBatchWrite, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Get span by id
     *
     * @param {string} id
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.getSpanById("id")
     */
    getSpanById(id: string, requestOptions?: Spans.RequestOptions): Promise<SpanPublic>;
    /**
     * Delete span by id
     *
     * @param {string} id
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotImplementedError}
     *
     * @example
     *     await client.spans.deleteSpanById("id")
     */
    deleteSpanById(id: string, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Update span by id
     *
     * @param {string} id
     * @param {OpikApi.SpanUpdate} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.updateSpan("id", {
     *         traceId: "trace_id"
     *     })
     */
    updateSpan(id: string, request: SpanUpdate$1, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Delete span comments
     *
     * @param {OpikApi.BatchDelete} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.deleteSpanComments({
     *         ids: ["ids"]
     *     })
     */
    deleteSpanComments(request: BatchDelete, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Delete span feedback score
     *
     * @param {string} id
     * @param {OpikApi.DeleteFeedbackScore} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.deleteSpanFeedbackScore("id", {
     *         name: "name"
     *     })
     */
    deleteSpanFeedbackScore(id: string, request: DeleteFeedbackScore, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Find Feedback Score names
     *
     * @param {OpikApi.FindFeedbackScoreNames1Request} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.findFeedbackScoreNames1()
     */
    findFeedbackScoreNames1(request?: FindFeedbackScoreNames1Request, requestOptions?: Spans.RequestOptions): Promise<string[]>;
    /**
     * Get span comment
     *
     * @param {string} commentId
     * @param {string} spanId
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.getSpanComment("commentId", "spanId")
     */
    getSpanComment(commentId: string, spanId: string, requestOptions?: Spans.RequestOptions): Promise<Comment>;
    /**
     * Get span stats
     *
     * @param {OpikApi.GetSpanStatsRequest} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.getSpanStats()
     */
    getSpanStats(request?: GetSpanStatsRequest, requestOptions?: Spans.RequestOptions): Promise<ProjectStatsPublic>;
    /**
     * Batch feedback scoring for spans
     *
     * @param {OpikApi.FeedbackScoreBatch} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.scoreBatchOfSpans({
     *         scores: [{
     *                 id: "id",
     *                 name: "name",
     *                 value: 1.1,
     *                 source: "ui"
     *             }]
     *     })
     */
    scoreBatchOfSpans(request: FeedbackScoreBatch, requestOptions?: Spans.RequestOptions): Promise<void>;
    /**
     * Search spans
     * @throws {@link OpikApi.BadRequestError}
     */
    searchSpans(request?: SpanSearchStreamRequestPublic, requestOptions?: Spans.RequestOptions): Promise<stream.Readable>;
    /**
     * Update span comment by id
     *
     * @param {string} commentId
     * @param {OpikApi.Comment} request
     * @param {Spans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.updateSpanComment("commentId", {
     *         text: "text"
     *     })
     */
    updateSpanComment(commentId: string, request: Comment, requestOptions?: Spans.RequestOptions): Promise<void>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Traces {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Trace related resources
 */
declare class Traces {
    protected readonly _options: Traces.Options;
    constructor(_options?: Traces.Options);
    /**
     * Add trace comment
     *
     * @param {string} id
     * @param {OpikApi.Comment} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.addTraceComment("id", {
     *         text: "text"
     *     })
     */
    addTraceComment(id: string, request: Comment, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Add trace feedback score
     *
     * @param {string} id
     * @param {OpikApi.FeedbackScore} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.addTraceFeedbackScore("id", {
     *         name: "name",
     *         value: 1.1,
     *         source: "ui"
     *     })
     */
    addTraceFeedbackScore(id: string, request: FeedbackScore, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Get traces by project_name or project_id
     *
     * @param {OpikApi.GetTracesByProjectRequest} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTracesByProject()
     */
    getTracesByProject(request?: GetTracesByProjectRequest, requestOptions?: Traces.RequestOptions): Promise<TracePagePublic>;
    /**
     * Get trace
     *
     * @param {OpikApi.TraceWrite} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.createTrace({
     *         name: "name",
     *         startTime: "2024-01-15T09:30:00Z"
     *     })
     */
    createTrace(request: TraceWrite, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Create traces
     *
     * @param {OpikApi.TraceBatchWrite} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.createTraces({
     *         traces: [{
     *                 name: "name",
     *                 startTime: "2024-01-15T09:30:00Z"
     *             }]
     *     })
     */
    createTraces(request: TraceBatchWrite, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Get trace by id
     *
     * @param {string} id
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceById("id")
     */
    getTraceById(id: string, requestOptions?: Traces.RequestOptions): Promise<TracePublic>;
    /**
     * Delete trace by id
     *
     * @param {string} id
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceById("id")
     */
    deleteTraceById(id: string, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Update trace by id
     *
     * @param {string} id
     * @param {OpikApi.TraceUpdate} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.updateTrace("id")
     */
    updateTrace(id: string, request?: TraceUpdate, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Delete trace comments
     *
     * @param {OpikApi.BatchDelete} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceComments({
     *         ids: ["ids"]
     *     })
     */
    deleteTraceComments(request: BatchDelete, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Delete trace feedback score
     *
     * @param {string} id
     * @param {OpikApi.DeleteFeedbackScore} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceFeedbackScore("id", {
     *         name: "name"
     *     })
     */
    deleteTraceFeedbackScore(id: string, request: DeleteFeedbackScore, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Delete trace threads
     *
     * @param {OpikApi.DeleteTraceThreads} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceThreads({
     *         threadIds: ["thread_ids"]
     *     })
     */
    deleteTraceThreads(request: DeleteTraceThreads, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Delete traces
     *
     * @param {OpikApi.BatchDelete} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraces({
     *         ids: ["ids"]
     *     })
     */
    deleteTraces(request: BatchDelete, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Find Feedback Score names
     *
     * @param {OpikApi.FindFeedbackScoreNames2Request} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.findFeedbackScoreNames2()
     */
    findFeedbackScoreNames2(request?: FindFeedbackScoreNames2Request, requestOptions?: Traces.RequestOptions): Promise<string[]>;
    /**
     * Get trace stats
     *
     * @param {OpikApi.GetTraceStatsRequest} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceStats()
     */
    getTraceStats(request?: GetTraceStatsRequest, requestOptions?: Traces.RequestOptions): Promise<ProjectStatsPublic>;
    /**
     * Get trace comment
     *
     * @param {string} commentId
     * @param {string} traceId
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.getTraceComment("commentId", "traceId")
     */
    getTraceComment(commentId: string, traceId: string, requestOptions?: Traces.RequestOptions): Promise<Comment>;
    /**
     * Get trace thread
     *
     * @param {OpikApi.TraceThreadIdentifier} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.getTraceThread({
     *         projectId: "project_id",
     *         threadId: "thread_id"
     *     })
     */
    getTraceThread(request: TraceThreadIdentifier, requestOptions?: Traces.RequestOptions): Promise<TraceThread>;
    /**
     * Get trace threads
     *
     * @param {OpikApi.GetTraceThreadsRequest} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceThreads()
     */
    getTraceThreads(request?: GetTraceThreadsRequest, requestOptions?: Traces.RequestOptions): Promise<TraceThreadPage>;
    /**
     * Batch feedback scoring for traces
     *
     * @param {OpikApi.FeedbackScoreBatch} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.scoreBatchOfTraces({
     *         scores: [{
     *                 id: "id",
     *                 name: "name",
     *                 value: 1.1,
     *                 source: "ui"
     *             }]
     *     })
     */
    scoreBatchOfTraces(request: FeedbackScoreBatch, requestOptions?: Traces.RequestOptions): Promise<void>;
    /**
     * Update trace comment by id
     *
     * @param {string} commentId
     * @param {OpikApi.Comment} request
     * @param {Traces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.updateTraceComment("commentId", {
     *         text: "text"
     *     })
     */
    updateTraceComment(commentId: string, request: Comment, requestOptions?: Traces.RequestOptions): Promise<void>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Workspaces {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
/**
 * Workspace related resources
 */
declare class Workspaces {
    protected readonly _options: Workspaces.Options;
    constructor(_options?: Workspaces.Options);
    /**
     * @param {Workspaces.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.workspaces.getWorkspaceMetadata()
     */
    getWorkspaceMetadata(requestOptions?: Workspaces.RequestOptions): Promise<WorkspaceMetadata>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace OpikApiClient {
    interface Options {
        environment?: Supplier<OpikApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: Supplier<string>;
        /** Override the Authorization header */
        apiKey?: Supplier<string | undefined>;
        /** Override the Comet-Workspace header */
        workspaceName?: Supplier<string | undefined>;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        apiKey?: string | undefined;
        /** Override the Comet-Workspace header */
        workspaceName?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
declare class OpikApiClient {
    protected readonly _options: OpikApiClient.Options;
    protected _systemUsage: SystemUsage | undefined;
    protected _check: Check | undefined;
    protected _automationRuleEvaluators: AutomationRuleEvaluators | undefined;
    protected _chatCompletions: ChatCompletions | undefined;
    protected _datasets: Datasets | undefined;
    protected _experiments: Experiments | undefined;
    protected _feedbackDefinitions: FeedbackDefinitions | undefined;
    protected _llmProviderKey: LlmProviderKey | undefined;
    protected _openTelemetryIngestion: OpenTelemetryIngestion | undefined;
    protected _projects: Projects | undefined;
    protected _prompts: Prompts | undefined;
    protected _spans: Spans | undefined;
    protected _traces: Traces | undefined;
    protected _workspaces: Workspaces | undefined;
    constructor(_options?: OpikApiClient.Options);
    get systemUsage(): SystemUsage;
    get check(): Check;
    get automationRuleEvaluators(): AutomationRuleEvaluators;
    get chatCompletions(): ChatCompletions;
    get datasets(): Datasets;
    get experiments(): Experiments;
    get feedbackDefinitions(): FeedbackDefinitions;
    get llmProviderKey(): LlmProviderKey;
    get openTelemetryIngestion(): OpenTelemetryIngestion;
    get projects(): Projects;
    get prompts(): Prompts;
    get spans(): Spans;
    get traces(): Traces;
    get workspaces(): Workspaces;
    /**
     * @param {OpikApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.isAlive()
     */
    isAlive(requestOptions?: OpikApiClient.RequestOptions): Promise<unknown>;
    /**
     * @param {OpikApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.version()
     */
    version(requestOptions?: OpikApiClient.RequestOptions): Promise<unknown>;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string | undefined;
    }>;
}

interface SavedSpan extends Span$1 {
    id: string;
}
declare class Span {
    data: SavedSpan;
    private opik;
    constructor(data: SavedSpan, opik: OpikClient);
    end: () => this;
    score: (score: {
        name: string;
        categoryName?: string;
        value: number;
        reason?: string;
    }) => void;
    update: (updates: Omit<SpanUpdate$1, "traceId" | "parentSpanId" | "projectId" | "projectName">) => this;
}

interface SavedTrace extends Trace$1 {
    id: string;
}
interface SpanData extends Omit<Span$1, "startTime" | "traceId"> {
    startTime?: Date;
}
declare class Trace {
    data: SavedTrace;
    private opik;
    private spans;
    constructor(data: SavedTrace, opik: OpikClient);
    end: () => this;
    score: (score: {
        name: string;
        categoryName?: string;
        value: number;
        reason?: string;
    }) => void;
    span: (spanData: SpanData) => Span;
    update: (updates: Omit<TraceUpdate, "projectId">) => this;
}

declare abstract class BatchQueue<EntityData = object, EntityId = string> {
    private readonly createQueue;
    private readonly updateQueue;
    private readonly deleteQueue;
    private readonly name;
    constructor({ delay, enableCreateBatch, enableDeleteBatch, name, }: {
        delay?: number;
        enableCreateBatch?: boolean;
        enableDeleteBatch?: boolean;
        name?: string;
    });
    protected abstract createEntities(entities: EntityData[]): Promise<void>;
    protected abstract getEntity(id: EntityId): Promise<EntityData | undefined>;
    protected abstract updateEntity(id: EntityId, updates: Partial<EntityData>): Promise<void>;
    protected abstract deleteEntities(ids: EntityId[]): Promise<void>;
    protected abstract getId(entity: EntityData): EntityId;
    create: (entity: EntityData) => void;
    get: (id: EntityId) => Promise<EntityData | undefined>;
    update: (id: EntityId, updates: Partial<EntityData>) => void;
    delete: (id: EntityId) => void;
    flush: () => Promise<void>;
}

type SpanUpdate = Partial<SavedSpan> & {
    traceId: string;
};
declare class SpanBatchQueue extends BatchQueue<SavedSpan> {
    private readonly api;
    constructor(api: OpikApiClient, delay?: number);
    protected getId(entity: SavedSpan): string;
    protected createEntities(spans: SavedSpan[]): Promise<void>;
    protected getEntity(id: string): Promise<SavedSpan>;
    protected updateEntity(id: string, updates: SpanUpdate): Promise<void>;
    protected deleteEntities(ids: string[]): Promise<void>;
}

type FeedbackScoreId$1 = {
    id: string;
    name: string;
};
declare class SpanFeedbackScoresBatchQueue extends BatchQueue<FeedbackScoreBatchItem, FeedbackScoreId$1> {
    private readonly api;
    constructor(api: OpikApiClient, delay?: number);
    protected getId(entity: FeedbackScoreBatchItem): {
        id: string;
        name: string;
    };
    protected createEntities(scores: FeedbackScoreBatchItem[]): Promise<void>;
    protected getEntity(): Promise<FeedbackScoreBatchItem | undefined>;
    protected updateEntity(): Promise<void>;
    protected deleteEntities(scoreIds: FeedbackScoreId$1[]): Promise<void>;
}

declare class TraceBatchQueue extends BatchQueue<SavedTrace> {
    private readonly api;
    constructor(api: OpikApiClient, delay?: number);
    protected getId(entity: SavedTrace): string;
    protected createEntities(traces: SavedTrace[]): Promise<void>;
    protected getEntity(id: string): Promise<SavedTrace>;
    protected updateEntity(id: string, updates: Partial<SavedTrace>): Promise<void>;
    protected deleteEntities(ids: string[]): Promise<void>;
}

type FeedbackScoreId = {
    id: string;
    name: string;
};
declare class TraceFeedbackScoresBatchQueue extends BatchQueue<FeedbackScoreBatchItem, FeedbackScoreId> {
    private readonly api;
    constructor(api: OpikApiClient, delay?: number);
    protected getId(entity: FeedbackScoreBatchItem): {
        id: string;
        name: string;
    };
    protected createEntities(scores: FeedbackScoreBatchItem[]): Promise<void>;
    protected getEntity(): Promise<FeedbackScoreBatchItem | undefined>;
    protected updateEntity(): Promise<void>;
    protected deleteEntities(scoreIds: FeedbackScoreId[]): Promise<void>;
}

interface TraceData extends Omit<Trace$1, "startTime"> {
    startTime?: Date;
}
declare class OpikClient {
    api: OpikApiClient;
    config: OpikConfig;
    spanBatchQueue: SpanBatchQueue;
    traceBatchQueue: TraceBatchQueue;
    spanFeedbackScoresBatchQueue: SpanFeedbackScoresBatchQueue;
    traceFeedbackScoresBatchQueue: TraceFeedbackScoresBatchQueue;
    private lastProjectNameLogged;
    constructor(explicitConfig?: Partial<OpikConfig>);
    private displayTraceLog;
    trace: (traceData: TraceData) => Trace;
    flush: () => Promise<void>;
}

export { OpikClient as O, Span as S, Trace as T, SpanType as a, type OpikConfig as b };
